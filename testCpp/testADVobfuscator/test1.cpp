#include<iostream>

template<int...I>
struct MetaString1{
    constexpr inline MetaString1(const char* str):
        buffer_{encrypt(str[I])...} {}

    const char* decrypt(){
        for(int i=0; i<sizeof...(I); ++i)
            buffer_[i] = decrypt(buffer_[i]);
        buffer_[sizeof...(I)] = 0;
        return buffer_;
    }

    const char* getBuffer(){
        return this->buffer_;
    }

private:
    constexpr char encrypt(char c) const { return c^0x55; }
    constexpr char decrypt(char c) const { return encrypt(c); }

private:
    char buffer_[sizeof...(I)+1];
};


#if 0
constexpr inline const char* operator "" _obfuscatoed1(const char* str, size_t)
{
    return MetaString1<0, 1, 2, 3, 4, 5>(str).decrypt();
}
#endif

#define  OBFUSCATED(str) (MetaString1<0,1,2,3,4,5>(str).decrypt())
#define  OBFUSCATED1(str) (MetaString1<0,1,2,3,4,5>(str).getBuffer())
// #define  OBFUSCATED2(str) (MetaString1<std::make_index_sequence<sizeof(str)+1>>(str).getBuffer())
#define  OBFUSCATED3(str) (MetaString2<sizeof(str)>(str))
#define  OBFUSCATED4(str) (MetaString2<sizeof(str)>(str).decrypt())

auto i = std::make_index_sequence<5>();

int main1(){
    // std::cout<<"what"_obfuscatoed1<<std::endl;
    // std::cout<<OBFUSCATED4("hello")<<std::endl;
    // std::string str = "what";
    // std::cout<<std::sizeof str <<std::endl;
    // std::cout<<i<<std::endl;
    // std::integer_sequence<std::size_t, 1,2,3,4,1,2,3> sequence;
    // sequence.
    return 0;
}

template<int... Ns> struct sequence
{
    // template<int I, int...Is>
    void print(){
        int dummy[sizeof...(Ns)] = {(std::cout<<Ns<<" ", 0)...};
    }
};

template<int... Ns> struct seq_gen;

// recursion case
template<int I, int... Ns>
struct seq_gen<I, Ns...>
{
    using type = typename seq_gen<I-1, I-1, Ns...>::type;
};

// recursion base
template<int ... Ns>
struct seq_gen<0, Ns...>
{
    using type = sequence<Ns...>;
};

// create sequence<0, 1, 2, ..., N> type
template<int N>
using sequence_t = typename seq_gen<N>::type;

#include<iostream>
#include<tuple>

using std::tuple;

static void func(double d, float f, int i){
    std::cout<<d<<", "<<f<<", "<<i<<std::endl;
}

template<typename F, typename TUP, int... INDICES>
static void tuple_call_(F f, TUP tup, sequence<INDICES...>)
{
    f(std::get<INDICES>(tup)...);
}

template<typename F, typename... Ts>
static void tuple_call(F f, tuple<Ts...> tup)
{
    tuple_call_(f, tup, sequence_t<sizeof...(Ts)>{});
}

// template<std::size_t I>
template<std::size_t... Is>
struct myMetaString2{
private:
    char buffer_[sizeof...(Is)];

public:
    myMetaString2(const char* str, sequence<Is...>):
        buffer_{encrypt(str[Is])...}
    {
    }

    char encrypt(char c) { return c^0x55; }
    char decrypt(char c) { return encrypt(c); }

    char* decrypt(){
        for(unsigned int i=0; i<sizeof...(Is); ++i){
            buffer_[i] = decrypt(buffer_[i]);
        }
        return buffer_;
    }

    friend std::ostream &operator<<(std::ostream &os, const myMetaString2 &str)
    {
        return os<<str.buffer_;
    }
};

/* following is code from advobfuscator
 *
 */

// TODO: ?? what's _MSC_VER
#if defined(_MSC_VER)
#define ALWAYS_INLINE __forceinline
#else
#define ALWAYS_INLINE __attribute__((always_inline))
#endif

/*
 * Index.h
 */
template<int... I>
struct Indexes { using type = Indexes<I..., sizeof...(I)>; };

template<int N>
struct Make_Indexes { using type = typename Make_Indexes<N-1>::type::type; };

template<>
struct Make_Indexes<0> { using type = Indexes<>; };

/**
 * MetaString2.hpp
 */
template<typename Indexes>
struct MetaString2;

// Partial specialization with a list of indexes I

template<int... I>
struct MetaString2<Indexes<I...>> // List of indexes generated by MakeIndexes
{
    // Constructor. Evaluated at compile time
    constexpr ALWAYS_INLINE MetaString2(const char* str)
        : buffer_ {encrypt(str[I])...} { }

    // Runtime decryption. Most of the time, inlined
    inline const char* decrypt()
    {
        for(size_t i = 0; i < sizeof...(I); ++i)
            buffer_[i] = decrypt(buffer_[i]);
        buffer_[sizeof...(I)] = 0;
        return buffer_;
    }

    friend std::ostream &operator<<(std::ostream &os, const MetaString2 &str){
        return os<<str.buffer_;
    }

    private:
    // Encrypt / decrypt a character of the original string
    constexpr char encrypt(char c) const { return c ^ 0x55; }
    constexpr char decrypt(char c) const { return encrypt(c); }

    // private:
    public:
    // Buffer to store the encrypted string + terminating null byte
    char buffer_[sizeof...(I) + 1];
};

#define mMetaString2(str) (MetaString2<Make_Indexes<sizeof(str)-1>::type>(str))
#define OBFUSCATED2(str)  (MetaString2<Make_Indexes<sizeof(str) - 1>::type>(str).decrypt())

// TODO: error??
/*
*/
int &add(int& i){
    return ++i;
}

constexpr inline int add(int i){
    return ++i;
}

int main(){
    // sequence_t<2> seq;
    // seq.print();
    // sequence_t<sizeof("what")> temp;
    // MetaString2 myStr("what", temp);
    // std::cout<<MetaString2<Make_Indexes<sizeof("what")-1>::type> ("what");
    auto str1 = new MetaString2<Make_Indexes<sizeof("what")-1>::type> ("what");
    // myMetaString2()
    // auto str = new  mMetaString2("what"); // error
    std::cout<<mMetaString2("what");
    std::cout<<OBFUSCATED2("what");
    // static_assert(OBFUSCATED2("what")[0]=='w', "");
    static_assert(add(1)==2,"");
    OBFUSCATED("hello1");
    const char * c = "hello2";
}
